{"name":"barinek/uservices","tagline":"Microservices and the Application Continuum","body":"### Introduction\r\n\r\nI've been part of several discussions recently that argue both for and against building applications with Microservices. In response, I've introduced the below diagram in conversation to show the evolution of an application starting from a monolith and evolving into several applications and components. Starting with a Monolith is just as viable as starting with Microservices, it simply depends on how much information you're given.\r\n\r\n![](https://raw.githubusercontent.com/barinek/uservices/master/evolve.png)\r\n\r\nProjects could start anywhere on the continuum, typically driven by the amount of information a team has about an application or set of applications. The less knowledge, the further left. The more knowledge, the further right.\r\n\r\nThe continuum is language agnostic and applies to any modern programming language.\r\n\r\n**Why is all this interesting?**\r\n\r\nIsn't this just an opinionated way to organize a code base?\r\n\r\nThe architecture is an approach that helps maintain a low cost of change over time by providing developers and product owners the ability to use and reuse components within a given code base to both pivot existing products and easily create new ones.\r\n\r\n### Project Structure\r\n\r\nI've used a series of Git commit tags to illustrate each step.\r\n\r\n```\r\n$ git tag -ln\r\n\r\nv1              First commit\r\nv2              Functional groups\r\nv3              Feature groups\r\nv4              Components\r\nv5              Services\r\n```\r\n\r\nThe example project is an issue tracking tool similar to Pivotal Tracker. Although not the actual codebase, Tracker followed a very similar evolution in application architecture. I've penciled in a few key epic features - Allocations, Backlog Management, and Time Tracking.\r\n\r\nNote - I've focused on the back-end development, but there's no reason you couldn't take a similar approach for the front end work. The project also includes only a few dependencies (Jetty and Jackson) and resides within a single Git repository (more about that later). I've also tried to be slightly framework agnostic although, [Spring Boot](http://projects.spring.io/spring-boot/), [Netflix Pytheas] (https://github.com/Netflix/pytheas) and [Dropwizard](http://dropwizard.io/) would have worked just as easily.\r\n\r\nHere's a helpful command when moving through the Git tags\r\n\r\n```\r\n$ git checkout v1 && git clean -df\r\n```\r\n\r\n###  (v1) First commit\r\n\r\nThe v1 tag starts with a flat directory structure. This step, while slightly naive, demonstrates a reasonable starting point having made no decisions around architecture. No groupings, no components, no services. Just a single, flat directory structure with class files.\r\n\r\n###  (v2) Functional groups\r\n\r\nv2 moves classes into Models, Controllers, Data Access Layer, and Utilities directories. I've noticed this directory structure over the years in many popular frameworks, although I've found that as your application grows, a change to a small feature tends to drive changes through your entire code base.\r\n\r\nFunctional groups become increasingly painful to maintain as teams grow and the complexity and size of the code base increase. This is especially true when dependencies are not fully understood. I've found that this is typically the result of accidental design versus intentional design. For this reason, I've reverted the Functional groups commit in favor of v3, Feature groups.\r\n\r\n###  (v3) Feature groups\r\n\r\nThe v3 commit moves classes into feature groups. The benefit of feature groups are readability and a step toward isolated (loosely coupled, highly cohesive) components.\r\n\r\n**Why is readability important?**\r\n\r\nImagine you've just joined the team and pulled the next story from the top of the backlog, Update Timesheets. With functional groups, you would have to scan the entire code base for timesheet related file changes. As the size of your code base increases, the potential to overlook associated files that also need updating increases. Again, this is especially true as code bases increase in both size and complexity. Using feature groups, all the timesheet related files are in one place with any complexity confined to a single directory.\r\n\r\nThe step toward single responsibility directories, while small, positions the code base for v4, individual components with bounded contexts.\r\n\r\n###  (v4) Components\r\n\r\nIn the v4 commit I've extracted the Users, Accounts, and Projects components. I've also extracted components for rest-support and jdbc-support, making a conscious effort to avoid creating a \"common\" package.\r\n\r\nThe main characteristic of the v4 commit is that each component is individually built and tested. This is similar to feature groups (loosely coupled and highly cohesive). Dependencies are clearly described within the build file and circular dependencies are resolved. The v4 commit sets us up nicely to introduce Services.\r\n\r\nNote - I've created a Schema package although this is slightly atypical. Data definition language within each component is more common permitting a per component data store.\r\n\r\n###  (v5) Services\r\n\r\nThe v5 commit introduces 4 distinct services - Allocations, Backlog, Registration, and Timesheets.\r\n\r\nThe Registration Service includes a simple REST API to access Account, Project, and User information. The service itself is very minimal leaving domain logic within components. The Allocations, Backlog, and Timesheets Services include a REST API, domain logic, and persistence layer. An alternate structure might have been to create components for each feature group similar to the Registration Service.\r\n\r\nI've found that scaling both teams and performance are typically the main drivers for moving components to services.\r\n\r\nNote - You'll notice that I've maintained a single Git repo. The single repo significantly reduces the overhead and complexity of API (in-process or REST) versioning while enabling cross-component refactorings. The assumption is that Services are stateless, well-tested, and able to be deployed with the larger suite of Components and Services regardless of any local changes. They are also only consumed by the single \"large\" application. I understand that this topic is slightly controversial although, I highly encourage you to explore having a single repository.\r\n\r\nI've also included an integration or acceptance test that \"flows\" through the suite of services and a multi-service manifest file for deployment.\r\n\r\n###  Summary\r\n\r\nThat's a wrap! Assuming you're on board with the application continuum, I'm hopeful the uServices project has given you insight in how an application evolves over time.\r\n\r\nApplications may start anywhere on the continuum depending on how much information the team has at the start of the project; greenfield applications may start left while big re-writes may start on the far right. Functional groupings could prove challenging when evolving along the continuum. Finally, it's also worth mentioning that not all applications need to evolve and could stop anywhere on the continuum.\r\n\r\nThanks! (@barinek)\r\n\r\n...and thanks again to (@dajulia3), (@enocom), (@shageman), and (@austinbv) for the feedback!\r\n\r\n**Update #1** - The transition from step v4 to v5 shouldn't be taken lightly. The move to Services is more than just an implementation detail and requires real and continued attention. Service availability (retry), versioning (esp. deploying \"breaking changes\") are just a few of the topics that become top of mind daily.\r\n\r\n**Update #2** - The v4-spring-boot and v5-spring-boot tags include the latest support for spring-boot. You'll notice that both rest-support and jdbc-support have been replaced with spring-boot-starter-web and spring-boot-starter-jdbc dependencies. In addition, the BasicApp has been replaced with a SpringApplication. Thanks, (@joshlong)!\r\n\r\n","google":"UA-61007704-1","note":"Don't delete this file! It's used internally to help with page regeneration."}