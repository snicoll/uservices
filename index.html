<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Uservices : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Uservices</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/barinek/uservices">View on GitHub</a>

          <h1 id="project_title">Uservices</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/barinek/uservices/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/barinek/uservices/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>I've been part of several discussions recently that argue both for and against building applications with Microservices. In response, I've introduced the below diagram, the Application Continuum, in conversation to show the evolution of an application starting from a monolith and evolving into several applications and components. Starting with a Monolith is just as viable as starting with Microservices, it simply depends on how much information you're given.</p>

<p><img src="https://raw.githubusercontent.com/barinek/uservices/master/evolve.png" alt=""></p>

<p>Projects could start anywhere on the continuum, typically driven by the amount of information a team has about an application or set of applications. The less knowledge, the further left. The more knowledge, the further right.</p>

<p>The continuum is language agnostic and applies to any modern programming language.</p>

<p><strong>Why is all this interesting?</strong></p>

<p>Isn't this just an opinionated way to organize a code base?</p>

<p>The architecture is an approach that helps maintain a low cost of change over time by providing developers and product owners the ability to use and reuse components within a given code base to both pivot existing products and easily create new ones.</p>

<h3>
<a id="project-structure" class="anchor" href="#project-structure" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project Structure</h3>

<p>I've used a series of Git commit tags to illustrate each step.</p>

<pre><code>$ git tag -ln

v1              First commit
v2              Functional groups
v3              Feature groups
v4              Components
v5              Services
</code></pre>

<p>The example project is an issue tracking tool similar to Pivotal Tracker. Although not the actual codebase, Tracker followed a very similar evolution in application architecture. I've penciled in a few key epic features - Allocations, Backlog Management, and Time Tracking.</p>

<p>Note - I've focused on the back-end development, but there's no reason you couldn't take a similar approach for the front end work. The project also includes only a few dependencies (Jetty and Jackson) and resides within a single Git repository (more about that later). I've also tried to be slightly framework agnostic although, <a href="http://projects.spring.io/spring-boot/">Spring Boot</a>, <a href="https://github.com/Netflix/pytheas">Netflix Pytheas</a> and <a href="http://dropwizard.io/">Dropwizard</a> would have worked just as easily.</p>

<p>Here's a helpful command when moving through the Git tags</p>

<pre><code>$ git checkout v1 &amp;&amp; git clean -df
</code></pre>

<h3>
<a id="v1-first-commit" class="anchor" href="#v1-first-commit" aria-hidden="true"><span class="octicon octicon-link"></span></a>(v1) First commit</h3>

<p>The v1 tag starts with a flat directory structure. This step, while slightly naive, demonstrates a reasonable starting point having made no decisions around architecture. No groupings, no components, no services. Just a single, flat directory structure with class files.</p>

<h3>
<a id="v2-functional-groups" class="anchor" href="#v2-functional-groups" aria-hidden="true"><span class="octicon octicon-link"></span></a>(v2) Functional groups</h3>

<p>v2 moves classes into Models, Controllers, Data Access Layer, and Utilities directories. I've noticed this directory structure over the years in many popular frameworks, although I've found that as your application grows, a change to a small feature tends to drive changes through your entire code base.</p>

<p>Functional groups become increasingly painful to maintain as teams grow and the complexity and size of the code base increase. This is especially true when dependencies are not fully understood. I've found that this is typically the result of <strong>accidental design versus intentional design</strong>. For this reason, I've reverted the Functional groups commit in favor of v3, Feature groups.</p>

<h3>
<a id="v3-feature-groups" class="anchor" href="#v3-feature-groups" aria-hidden="true"><span class="octicon octicon-link"></span></a>(v3) Feature groups</h3>

<p>The v3 commit moves classes into feature groups. The benefit of feature groups are readability and a step toward isolated (loosely coupled, highly cohesive) components.</p>

<p><strong>Why is readability important?</strong></p>

<p>Imagine you've just joined the team and pulled the next story from the top of the backlog, Update Timesheets. With functional groups, you would have to scan the entire code base for timesheet related file changes. As the size of your code base increases, the potential to overlook associated files that also need updating increases. Again, this is especially true as code bases increase in both size and complexity. Using feature groups, all the timesheet related files are in one place with any complexity confined to a single directory.</p>

<p>The step toward single responsibility directories, while small, positions the code base for v4, individual components with bounded contexts.</p>

<h3>
<a id="v4-components" class="anchor" href="#v4-components" aria-hidden="true"><span class="octicon octicon-link"></span></a>(v4) Components</h3>

<p>In the v4 commit I've extracted the Users, Accounts, and Projects components. I've also extracted components for rest-support and jdbc-support, making a conscious effort to avoid creating a "common" package.</p>

<p>The main characteristic of the v4 commit is that each component is individually built and tested. This is similar to feature groups (loosely coupled and highly cohesive). Dependencies are clearly described within the build file and circular dependencies are resolved. The v4 commit sets us up nicely to introduce Services.</p>

<p>Note - I've created a Schema package although this is slightly atypical. Data definition language within each component is more common permitting a per component data store.</p>

<h3>
<a id="v5-services" class="anchor" href="#v5-services" aria-hidden="true"><span class="octicon octicon-link"></span></a>(v5) Services</h3>

<p>The v5 commit introduces 4 distinct services - Allocations, Backlog, Registration, and Timesheets.</p>

<p>The Registration Service includes a simple REST API to access Account, Project, and User information. The service itself is very minimal leaving domain logic within components. The Allocations, Backlog, and Timesheets Services include a REST API, domain logic, and persistence layer. An alternate structure might have been to create components for each feature group similar to the Registration Service.</p>

<p>I've found that scaling both teams and performance are typically the main drivers for moving components to services.</p>

<p>Note - You'll notice that I've maintained a single Git repo. The single repo significantly reduces the overhead and complexity of API (in-process or REST) versioning while enabling cross-component refactorings. The assumption is that Services are stateless, well-tested, and able to be deployed with the larger suite of Components and Services regardless of any local changes. They are also only consumed by the single "large" application. I understand that this topic is slightly controversial although, I highly encourage you to explore having a single repository.</p>

<p>I've also included an integration or acceptance test that "flows" through the suite of services and a multi-service manifest file for deployment.</p>

<h3>
<a id="summary" class="anchor" href="#summary" aria-hidden="true"><span class="octicon octicon-link"></span></a>Summary</h3>

<p>That's a wrap! Assuming you're on board with the application continuum, I'm hopeful the uServices project has given you insight in how an application evolves over time.</p>

<p>Applications may start anywhere on the continuum depending on how much information the team has at the start of the project; greenfield applications may start left while big re-writes may start on the far right. Functional groupings could prove challenging when evolving along the continuum. Finally, it's also worth mentioning that not all applications need to evolve and could stop anywhere on the continuum.</p>

<p>Thanks! (<a href="https://github.com/barinek" class="user-mention">@barinek</a>)</p>

<p>...and thanks again to (<a href="https://github.com/dajulia3" class="user-mention">@dajulia3</a>) and (<a href="https://github.com/austinbv" class="user-mention">@austinbv</a>) for the copy edit!</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Uservices maintained by <a href="https://github.com/barinek">barinek</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-61007704-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
